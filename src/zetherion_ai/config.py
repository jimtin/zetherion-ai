"""Configuration management for Zetherion AI."""

from functools import lru_cache
from typing import Self

from pydantic import Field, SecretStr, field_validator, model_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",
        # Don't try to parse env vars as JSON for complex types
        env_parse_none_str="",
        # Disable JSON parsing for environment variables
        env_parse_enums=True,
    )

    # Discord
    discord_token: SecretStr = Field(description="Discord bot token")
    allowed_user_ids_str: str | None = Field(
        default=None,
        alias="ALLOWED_USER_IDS",
        description="Discord user IDs allowed to interact (comma-separated)",
    )

    @property
    def allowed_user_ids(self) -> list[int]:
        """Parse and return allowed user IDs as a list."""
        if self.allowed_user_ids_str is None:
            return []
        value = self.allowed_user_ids_str.strip()
        if not value:
            return []
        return [int(uid.strip()) for uid in value.split(",") if uid.strip()]

    # Gemini (for embeddings)
    gemini_api_key: SecretStr = Field(description="Gemini API key for embeddings")

    # Anthropic (optional, for Claude LLM)
    anthropic_api_key: SecretStr | None = Field(
        default=None, description="Anthropic API key for Claude"
    )

    # OpenAI (optional, alternative LLM)
    openai_api_key: SecretStr | None = Field(default=None, description="OpenAI API key")

    # Qdrant
    qdrant_host: str = Field(default="qdrant", description="Qdrant server host")
    qdrant_port: int = Field(default=6333, description="Qdrant server port")
    qdrant_use_tls: bool = Field(default=False, description="Use TLS for Qdrant connection")
    qdrant_cert_path: str | None = Field(
        default=None, description="Path to Qdrant TLS certificate for verification"
    )

    # Application
    environment: str = Field(default="production", description="Environment name")
    log_level: str = Field(default="INFO", description="Logging level")

    # Logging Configuration
    log_to_file: bool = Field(default=True, description="Enable file-based logging")
    log_directory: str = Field(default="logs", description="Directory for log files")
    log_file_max_bytes: int = Field(
        default=10485760,  # 10MB
        description="Max size per log file before rotation",
    )
    log_file_backup_count: int = Field(default=5, description="Number of rotated log files to keep")

    # Testing Configuration
    allow_bot_messages: bool = Field(
        default=False, description="Allow messages from other bots (for E2E testing only)"
    )

    @property
    def log_file_path(self) -> str:
        """Get the full log file path."""
        return f"{self.log_directory}/zetherion_ai.log"

    # Model Configuration
    # Updated: 2026-02-05
    # Check for latest versions:
    # - Claude: https://docs.anthropic.com/en/docs/about-claude/models
    # - OpenAI: https://platform.openai.com/docs/models
    # - Gemini: https://ai.google.dev/gemini-api/docs/models
    claude_model: str = Field(
        default="claude-sonnet-4-5-20250929", description="Claude model to use for complex tasks"
    )
    openai_model: str = Field(
        default="gpt-4o",  # or gpt-4o-2024-11-20 for specific version
        description="OpenAI model to use for complex tasks",
    )
    router_model: str = Field(
        default="gemini-2.5-flash",  # Stable, fast model for routing
        description="Gemini model to use for routing and simple queries",
    )
    embedding_model: str = Field(default="text-embedding-004", description="Gemini embedding model")

    # Router Backend Configuration
    router_backend: str = Field(
        default="gemini", description="Router backend: 'gemini' or 'ollama'"
    )

    # Ollama Configuration
    ollama_host: str = Field(default="ollama", description="Ollama container host")
    ollama_port: int = Field(default=11434, description="Ollama API port")
    ollama_router_model: str = Field(default="llama3.1:8b", description="Ollama model for routing")
    ollama_embedding_model: str = Field(
        default="nomic-embed-text", description="Ollama model for embeddings (768 dimensions)"
    )
    ollama_timeout: int = Field(default=30, description="Ollama API timeout in seconds")

    # Embeddings Backend Configuration
    embeddings_backend: str = Field(
        default="ollama",
        description="Embeddings backend: 'ollama' (local, default) or 'gemini' (cloud)",
    )

    # Encryption Configuration (Phase 5A)
    encryption_enabled: bool = Field(
        default=True, description="Enable field-level encryption for sensitive data"
    )
    encryption_passphrase: SecretStr | None = Field(
        default=None, description="Master passphrase for encryption key derivation (min 16 chars)"
    )
    encryption_salt_path: str = Field(
        default="data/salt.bin", description="Path to store the encryption salt file"
    )

    # InferenceBroker Configuration (Phase 5B)
    inference_broker_enabled: bool = Field(
        default=True, description="Enable smart multi-provider routing via InferenceBroker"
    )
    cost_tracking_enabled: bool = Field(
        default=True, description="Track costs per provider and task type"
    )

    # Model Registry Configuration (Phase 5B.1)
    model_discovery_enabled: bool = Field(
        default=True, description="Enable automatic model discovery from provider APIs"
    )
    model_refresh_hours: int = Field(
        default=24, description="Hours between model discovery refreshes"
    )
    anthropic_tier: str = Field(
        default="balanced", description="Default tier for Anthropic models: quality, balanced, fast"
    )
    openai_tier: str = Field(
        default="balanced", description="Default tier for OpenAI models: quality, balanced, fast"
    )
    google_tier: str = Field(
        default="fast", description="Default tier for Google models: quality, balanced, fast"
    )

    # Cost Tracking Configuration (Phase 5B.1)
    cost_db_path: str = Field(
        default="data/costs.db", description="Path to SQLite database for cost tracking"
    )
    daily_budget_usd: float | None = Field(
        default=None, description="Optional daily budget threshold in USD for alerts"
    )
    monthly_budget_usd: float | None = Field(
        default=None, description="Optional monthly budget threshold in USD for alerts"
    )
    budget_warning_pct: float = Field(
        default=80.0, description="Percentage of budget at which to send warning (0-100)"
    )

    # Notification Configuration (Phase 5B.1)
    notifications_enabled: bool = Field(
        default=True, description="Enable cost and model notifications"
    )
    notify_on_new_models: bool = Field(
        default=True, description="Send notification when new models are discovered"
    )
    notify_on_deprecation: bool = Field(
        default=True, description="Send notification when models are deprecated"
    )
    notify_on_missing_pricing: bool = Field(
        default=False, description="Send notification for models without pricing data"
    )
    daily_summary_enabled: bool = Field(
        default=False, description="Send daily cost summary notification"
    )
    daily_summary_hour: int = Field(default=9, description="Hour (0-23) to send daily cost summary")

    # Profile System Configuration (Phase 5C)
    profile_inference_enabled: bool = Field(
        default=True, description="Enable profile extraction from conversations"
    )
    profile_tier1_only: bool = Field(
        default=False, description="Only use Tier 1 (free regex) inference for profiles"
    )
    profile_confidence_threshold: float = Field(
        default=0.6, description="Minimum confidence to auto-apply profile updates"
    )
    profile_cache_ttl: int = Field(
        default=300, description="Profile cache TTL in seconds (default 5 min)"
    )
    profile_db_path: str = Field(
        default="data/profiles.db",
        description="Path to SQLite database for profile operational data",
    )
    profile_max_pending_confirmations: int = Field(
        default=5, description="Maximum pending confirmations per user"
    )
    profile_confirmation_expiry_hours: int = Field(
        default=72, description="Hours before pending confirmations expire"
    )

    # Employment Profile Defaults (Phase 5C.1)
    default_formality: float = Field(
        default=0.5, description="Initial formality level (0=casual, 1=formal)"
    )
    default_verbosity: float = Field(
        default=0.5, description="Initial verbosity level (0=terse, 1=detailed)"
    )
    default_proactivity: float = Field(
        default=0.3, description="Initial proactivity level (0=reactive, 1=proactive)"
    )
    trust_evolution_rate: float = Field(
        default=0.05, description="How fast trust builds per positive interaction"
    )

    # Skills Service Configuration (Phase 5D)
    skills_service_url: str = Field(
        default="http://zetherion_ai-skills:8080",
        description="URL of the skills service (internal Docker network)",
    )
    skills_api_secret: SecretStr | None = Field(
        default=None, description="Shared secret for skills service authentication"
    )
    skills_request_timeout: int = Field(
        default=30, description="Timeout in seconds for skills service requests"
    )

    @field_validator(
        "profile_confidence_threshold",
        "default_formality",
        "default_verbosity",
        "default_proactivity",
        "trust_evolution_rate",
    )
    @classmethod
    def validate_float_0_1(cls, v: float) -> float:
        """Validate float values are between 0 and 1."""
        if not 0 <= v <= 1:
            raise ValueError(f"Value must be between 0 and 1, got: {v}")
        return v

    @field_validator("router_backend")
    @classmethod
    def validate_router_backend(cls, v: str) -> str:
        """Validate router backend choice."""
        valid_backends = ["gemini", "ollama"]
        if v not in valid_backends:
            raise ValueError(f"router_backend must be one of {valid_backends}, got: {v}")
        return v

    @field_validator("anthropic_tier", "openai_tier", "google_tier")
    @classmethod
    def validate_tier(cls, v: str) -> str:
        """Validate tier setting."""
        valid_tiers = ["quality", "balanced", "fast"]
        if v not in valid_tiers:
            raise ValueError(f"tier must be one of {valid_tiers}, got: {v}")
        return v

    @field_validator("budget_warning_pct")
    @classmethod
    def validate_budget_warning_pct(cls, v: float) -> float:
        """Validate budget warning percentage is between 0 and 100."""
        if not 0 <= v <= 100:
            raise ValueError(f"budget_warning_pct must be between 0 and 100, got: {v}")
        return v

    @field_validator("daily_summary_hour")
    @classmethod
    def validate_daily_summary_hour(cls, v: int) -> int:
        """Validate daily summary hour is between 0 and 23."""
        if not 0 <= v <= 23:
            raise ValueError(f"daily_summary_hour must be between 0 and 23, got: {v}")
        return v

    @model_validator(mode="after")
    def validate_encryption_config(self) -> Self:
        """Validate encryption configuration consistency."""
        if self.encryption_enabled:
            if self.encryption_passphrase is None:
                raise ValueError(
                    "encryption_passphrase is required when encryption_enabled is True"
                )
            passphrase = self.encryption_passphrase.get_secret_value()
            if len(passphrase) < 16:
                raise ValueError("encryption_passphrase must be at least 16 characters")
        return self

    @property
    def ollama_url(self) -> str:
        """Get the full Ollama URL."""
        return f"http://{self.ollama_host}:{self.ollama_port}"

    @property
    def is_development(self) -> bool:
        """Check if running in development mode."""
        return self.environment.lower() == "development"

    @property
    def qdrant_url(self) -> str:
        """Get the full Qdrant URL."""
        scheme = "https" if self.qdrant_use_tls else "http"
        return f"{scheme}://{self.qdrant_host}:{self.qdrant_port}"


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()  # type: ignore[call-arg]  # Pydantic loads from env vars
